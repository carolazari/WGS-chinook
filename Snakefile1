

# run it over the following  samples
SAMPLES = open ("samples.txt", "r")

# variant calling over these "chromosomes"
CHROMOS = [ "chromos.txt", "r"]

rule get_genome:
    output:
        "resources/genome.fasta",
    log:
        "results/bqsr-round-0/logs/get_genome.log",
    benchmark:
        "results/bqsr-round-0/benchmarks/get_genome/get_genome.bmk",
    params:
        url=config["ref"]["genome_url"],
    conda:
        "../envs/wget.yaml"
    shell:
        " (tmp_dir=$(mktemp -d) && "
        " URL={params.url} && "
        " if [[ $URL =~ \.gz$ ]]; then EXT='.gz'; else EXT=''; fi && "
        " wget -O $tmp_dir/file$EXT $URL && "
        " if [[ $URL =~ \.gz$ ]]; then gunzip $tmp_dir/file$EXT; fi && "
        " mv $tmp_dir/file {output}) > {log} 2>&1 "


rule genome_faidx: #I already have the reference genome indexed (it is the one .fna.fai) so maybe I can skip this step here.
  input:
    "Reference/chinook_ref.fasta", 
  output:
    "Reference/chinook_ref.fasta.fai",
  conda:
    "envs/bwa2sam.yaml"
  log:
    "results/logs/genome_faidx.log",
  shell:
    "samtools faidx {input} 2> {log} "


rule genome_dict:
  input:
    "Reference/chinook_ref.fasta",
  output:
    "Reference/chinook_ref.dict",
  conda:
    "envs/bwa2sam.yaml"
  log:
    "results/logs/genome_dict.log",
  shell:
    "samtools dict {input} > {output} 2> {log} "


rule bwa_index:
  input:
    "Reference/chinook_ref.fasta"
  output:
    multiext("Reference/chinook_ref.fasta", ".0123", ".amb", ".ann", ".bwt.2bit.64", ".pac"),
  conda:
    "envs/bwa2sam.yaml"
  log:
    out="results/logs/bwa_index/bwa_index.log",
    err="results/logs/bwa_index/bwa_index.err"
  shell:
    "bwa-mem2 index {input} > {log.out} 2> {log.err} "




rule trim_reads:
  input:
    r1="data/{sample}_R1.fastq.gz",
    r2="data/{sample}_R2.fastq.gz",
  output:
    r1="results/trimmed/{sample}_R1.fastq.gz",
    r2="results/trimmed/{sample}_R2.fastq.gz",
    html="results/qc/fastp/{sample}.html",
    json="results/qc/fastp/{sample}.json"
  conda:
    "envs/fastp.yaml"
  log:
    out="results/logs/trim_reads/{sample}.log",
    err="results/logs/trim_reads/{sample}.err",
  params:
    as1="AGATCGGAAGAGCACACGTCTGAACTCCAGTCA",
    as2="AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT",
    parm=" --detect_adapter_for_pe --cut_right --cut_right_window_size 4 --cut_right_mean_quality 20 "
  shell:
    " fastp -i {input.r1} -I {input.r2}       "
    "       -o {output.r1} -O {output.r2}     "
    "       -h {output.html} -j {output.json} "
    "  --adapter_sequence={params.as1}        "
    "  --adapter_sequence_r2={params.as2}     "
    "  {params.parm} > {log.out} 2> {log.err}                         "
    


rule map_reads:
  input:
    r1="results/trimmed/{sample}_R1.fastq.gz",
    r2="results/trimmed/{sample}_R2.fastq.gz",
    genome="Reference/chinook_ref.fasta",
    idx=multiext("Reference/chinook_ref.fasta", ".0123", ".amb", ".ann", ".bwt.2bit.64", ".pac")
  output:
    "results/bam/{sample}.bam"
  conda:
    "envs/bwa2sam.yaml"
  log:
    "results/logs/map_reads/{sample}.log"
  params:
    RG="-R '@RG\\tID:{sample}\\tSM:{sample}\\tPL:ILLUMINA' "
  shell:
    " (bwa-mem2 mem {params.RG} {input.genome} {input.r1} {input.r2} | "
    " samtools view -u | "
    " samtools sort - > {output}) 2> {log} "



# this is the hard-filtering routine recommended by
# the folks that develop the GATK.

# It marks sites as PASS in the FILTER column,
# or it writes out the name of the particular filters
# that were not passed.

rule make_snp_vcf:
    input:
        vcf="results/bqsr-round-{bqsr_round}/vcf_sect_miss_denoted/{sg_or_chrom}.vcf.gz",
        tbi="results/bqsr-round-{bqsr_round}/vcf_sect_miss_denoted/{sg_or_chrom}.vcf.gz.tbi"
    output:
        vcf="results/bqsr-round-{bqsr_round}/hard_filtering/snps-{sg_or_chrom}.vcf.gz",
        idx="results/bqsr-round-{bqsr_round}/hard_filtering/snps-{sg_or_chrom}.vcf.gz.tbi"
    log:
        "results/bqsr-round-{bqsr_round}/logs/gatk/selectvariants/select-snps-{sg_or_chrom}.log",
    benchmark:
        "results/bqsr-round-{bqsr_round}/benchmarks/make_snp_vcf/selectvariants-snps-{sg_or_chrom}.bmk"
    conda:
        "../envs/gatk4.2.6.1.yaml"
    shell:
        " gatk SelectVariants -V {input.vcf}  -select-type SNP -O {output.vcf} > {log} 2>&1 "



rule make_indel_vcf:
    input:
        vcf="results/bqsr-round-{bqsr_round}/vcf_sect_miss_denoted/{sg_or_chrom}.vcf.gz",
        tbi="results/bqsr-round-{bqsr_round}/vcf_sect_miss_denoted/{sg_or_chrom}.vcf.gz.tbi"
    output:
        vcf="results/bqsr-round-{bqsr_round}/hard_filtering/indels-{sg_or_chrom}.vcf.gz",
        idx="results/bqsr-round-{bqsr_round}/hard_filtering/indels-{sg_or_chrom}.vcf.gz.tbi"
    log:
        "results/bqsr-round-{bqsr_round}/logs/gatk/selectvariants/select-indels-{sg_or_chrom}.log",
    benchmark:
        "results/bqsr-round-{bqsr_round}/benchmarks/make_indel_vcf/selectvariants-indels-{sg_or_chrom}.bmk"
    conda:
        "../envs/gatk4.2.6.1.yaml"
    shell:
        " gatk SelectVariants -V {input.vcf}  -select-type INDEL -O {output.vcf} > {log} 2>&1 "




rule hard_filter_snps:
    input:
        vcf="results/bqsr-round-{bqsr_round}/hard_filtering/snps-{sg_or_chrom}.vcf.gz",
        idx="results/bqsr-round-{bqsr_round}/hard_filtering/snps-{sg_or_chrom}.vcf.gz.tbi"
    output:
        vcf="results/bqsr-round-{bqsr_round}/hard_filtering/snps-filtered-{sg_or_chrom}.vcf.gz",
        idx="results/bqsr-round-{bqsr_round}/hard_filtering/snps-filtered-{sg_or_chrom}.vcf.gz.tbi"
    log:
        "results/bqsr-round-{bqsr_round}/logs/gatk/variantfiltration/snps-{sg_or_chrom}.log",
    benchmark:
        "results/bqsr-round-{bqsr_round}/benchmarks/hard_filter_snps/variantfiltration-snps-{sg_or_chrom}.bmk"
    conda:
        "../envs/gatk4.2.6.1.yaml"
    shell:
        "gatk VariantFiltration "
        " -V {input.vcf} "
        "  -filter 'QD < 2.0' --filter-name 'QD2' "
        "  -filter 'QUAL < 30.0' --filter-name 'QUAL30' "
        "  -filter 'SOR > 3.0' --filter-name 'SOR3' "
        "  -filter 'FS > 60.0' --filter-name 'FS60' "
        "  -filter 'MQ < 40.0' --filter-name 'MQ40' "
        "  -filter 'MQRankSum < -12.5' --filter-name 'MQRankSum-12.5' "
        "  -filter 'ReadPosRankSum < -8.0' --filter-name 'ReadPosRankSum-8' "
        " -O {output.vcf} > {log} 2>&1 "




rule hard_filter_indels:
    input:
        vcf="results/bqsr-round-{bqsr_round}/hard_filtering/indels-{sg_or_chrom}.vcf.gz",
        idx="results/bqsr-round-{bqsr_round}/hard_filtering/indels-{sg_or_chrom}.vcf.gz.tbi"
    output:
        vcf="results/bqsr-round-{bqsr_round}/hard_filtering/indels-filtered-{sg_or_chrom}.vcf.gz",
        idx="results/bqsr-round-{bqsr_round}/hard_filtering/indels-filtered-{sg_or_chrom}.vcf.gz.tbi"
    log:
        "results/bqsr-round-{bqsr_round}/logs/gatk/variantfiltration/indels-{sg_or_chrom}.log",
    benchmark:
        "results/bqsr-round-{bqsr_round}/benchmarks/hard_filter_indels/variantfiltration-indels-{sg_or_chrom}.bmk"
    conda:
        "../envs/gatk4.2.6.1.yaml"
    shell:
        "gatk VariantFiltration "
        " -V {input.vcf} "
        "  -filter 'QD < 2.0' --filter-name 'QD2' "
        "  -filter 'QUAL < 30.0' --filter-name 'QUAL30' "
        "  -filter 'FS > 200.0' --filter-name 'FS200' "
        "  -filter 'ReadPosRankSum < -20.0' --filter-name 'ReadPosRankSum-20' "
        " -O {output.vcf} > {log} 2>&1 "




rule bung_filtered_vcfs_back_together:
    input:
        snp="results/bqsr-round-{bqsr_round}/hard_filtering/snps-filtered-{sg_or_chrom}.vcf.gz",
        indel="results/bqsr-round-{bqsr_round}/hard_filtering/indels-filtered-{sg_or_chrom}.vcf.gz",
        snp_idx="results/bqsr-round-{bqsr_round}/hard_filtering/snps-filtered-{sg_or_chrom}.vcf.gz.tbi",
        indel_idx="results/bqsr-round-{bqsr_round}/hard_filtering/indels-filtered-{sg_or_chrom}.vcf.gz.tbi"
    output:
        vcf="results/bqsr-round-{bqsr_round}/hard_filtering/both-filtered-{sg_or_chrom}.bcf",
    log:
        "results/bqsr-round-{bqsr_round}/logs/bung_filtered_vcfs_back_together/bung-{sg_or_chrom}.log",
    benchmark:
        "results/bqsr-round-{bqsr_round}/benchmarks/bung_filtered_vcfs_back_together/bcftools-{sg_or_chrom}.bmk"
    conda:
        "../envs/bcftools.yaml"
    shell:
        "(bcftools concat -a {input.snp} {input.indel} | "
        " bcftools view -Ob > {output.vcf}; ) 2> {log} "


rule maf_filter:
    input:
        "results/bqsr-round-{bqsr_round}/hard_filtering/both-filtered-{sg_or_chrom}.bcf"
    output:
        "results/bqsr-round-{bqsr_round}/hard_filtering/both-filtered-{sg_or_chrom}-maf-{maf}.bcf"
    log:
        "results/bqsr-round-{bqsr_round}/logs/maf_filter/{sg_or_chrom}-maf-{maf}.log",
    params:
        maf="{maf}"
    benchmark:
        "results/bqsr-round-{bqsr_round}/benchmarks/maf_filter/{sg_or_chrom}-maf-{maf}.bmk"
    conda:
        "../envs/bcftools.yaml"
    shell:
        " bcftools view -Ob -i 'FILTER=\"PASS\" & MAF > {params.maf} ' "
        " {input} > {output} 2>{log} "



#########



rule mark_duplicates:
  input:
    "results/bam/{sample}.bam"
  output:
    bam="results/mkdup/{sample}.bam",
    bai="results/mkdup/{sample}.bai",
    metrics="results/qc/mkdup_metrics/{sample}.metrics"
  conda:
    "envs/gatk.yaml"
  log:
    "results/logs/mark_duplicates/{sample}.log"
  shell:
    " gatk MarkDuplicates  "
    "  --CREATE_INDEX "
    "  -I {input} "
    "  -O {output.bam} "
    "  -M {output.metrics} > {log} 2>&1 "




rule make_gvcfs_by_chromo:
  input:
    bam="results/mkdup/{sample}.bam",
    bai="results/mkdup/{sample}.bai",
    ref="Reference/chinook_ref.fasta",
    idx="Reference/chinook_ref.dict",
    fai="Reference/chinook_ref.fasta.fai"
  output:
    gvcf="results/gvcf/{chromo}/{sample}.g.vcf.gz",
    idx="results/gvcf/{chromo}/{sample}.g.vcf.gz.tbi",
  conda:
    "envs/gatk.yaml"
  log:
    "results/logs/make_gvcfs_by_chromo/{chromo}/{sample}.log"
  params:
    java_opts="-Xmx4g"
  shell:
    " gatk --java-options \"{params.java_opts}\" HaplotypeCaller "
    " -R {input.ref} "
    " -I {input.bam} "
    " -O {output.gvcf} "
    " -L {wildcards.chromo}    "           
    " --native-pair-hmm-threads 1 " # this is just for this small example
    " -ERC GVCF > {log} 2> {log} "




rule import_genomics_db_by_chromo:
  input:
    gvcfs=expand("results/gvcf/{{chromo}}/{s}.g.vcf.gz", s=SAMPLES)
  output:
    gdb=directory("results/genomics_db/{chromo}")
  conda:
    "envs/gatk.yaml"
  log:
    "results/logs/import_genomics_db_by_chromo/{chromo}.log"
  params:
    java_opts="-Xmx4g"
  shell:
    " VS=$(for i in {input.gvcfs}; do echo -V $i; done); "  # make a string like -V file1 -V file2
    " gatk --java-options \"-Xmx4g\" GenomicsDBImport "
    "  $VS  "
    "  --genomicsdb-workspace-path {output.gdb} "
    "  -L  {wildcards.chromo} 2> {log} "




rule vcf_from_gdb_by_chromo:
  input:
    gdb="results/genomics_db/{chromo}",
    ref="Reference/chinook_ref.fasta",
    fai="Reference/chinook_ref.fasta.fai",
    idx="Reference/chinook_ref.dict",
  output:
    vcf="results/chromo_vcfs/{chromo}.vcf.gz",
    idx="results/chromo_vcfs/{chromo}.vcf.gz.tbi",
  conda:
    "envs/gatk.yaml"
  log:
    "results/logs/vcf_from_gdb_by_chromo/{chromo}.txt"
  shell:
    " gatk --java-options \"-Xmx4g\" GenotypeGVCFs "
    "  -R {input.ref}  "
    "  -V gendb://{input.gdb} "
    "  -O {output.vcf} 2> {log} "


rule concat_vcfs:
  input:
    vcfs=expand("results/chromo_vcfs/{c}.vcf.gz", c=CHROMOS)
  output:
    vcf="results/vcf/all.vcf.gz"
  conda:
    "envs/bcftools.yaml"
  log:
    "results/concat_vcfs/all.log"
  shell:
    "bcftools concat -n {input.vcfs} > {output.vcf} 2> {log} "
